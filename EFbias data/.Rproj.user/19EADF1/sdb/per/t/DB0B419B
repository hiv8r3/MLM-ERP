{
    "collab_server" : "",
    "contents" : "---\ntitle: ERN from EF bias\nauthor: Hannah, 3/9/2017\noutput:\n  html_document:\n    highlight: pygments\n    theme: cerulean\n  pdf_document: default\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\noptions(width=140)\nrequire(dplyr)\nrequire(ggplot2)\nrequire(lme4)\nrequire(lmerTest)\nrequire(colorspace)\nrequire(grid)\n```\n\nData from previously processed EEG files from CU and MU were used. Before I got them, the following was done:  \n\n1) CNT file was merged with dat file to add response latency and accuracy information to CNT file  \n2) CNT was re-referenced to average mastoids reference  \n3) Blinks were corrected for  \n4) A filter was applied (need to look up the settings for that)  \n5) Files were response-locked, with an epoch of -400 to 500  \n\nI subsequently:  \n\n1) Baseline corrected EEG files (using a baseline of -400 to -200)  \n2) Performed an automatic artifact rejected procedure (trials with +- 75 uV were rejected, only using 9 electrodes of interest as the criteria)  \n\nTrials were included if:  \n1) The RT was between 200 and 500 ms  \n2) A response was made (i.e., no miss trials)  \n3) The trial wasn't rejected in artifact rejection procedure  \n\nThe following subjects were excluded:    \n- 1040 (doesn't have full number of trials)  \n- 2023 (problems with EEG data)  \n- 2077 (problems with EEG data)  \n- 2089 (problems with EEG data)  \n- 2151 (problems with EEG data)  \n- 2157 (problems with EEG data)  \n- 2181 (problems with EEG data)  \n- 2187 (doesn't have full number of trials)  \n\nEach subject did 384 experimental trials (prime-only trials were also included but not in the 384).  \n\nFZ, F3, F4, FCZ, FC3, FC4, C3, CZ, C4 (9 electrodes) were included.\n\n**Total sample is 134 subjects, 60 from CU and 74 from MU.**\n\n\\textbf{Here are the number of error committed in each condition by each subject:}\n``` {r errCount, echo=F, eval=F}\nread.delim(\"ErrorsPerCondition.txt\")\n```\n\n\n### 1. ERN/CRN grand averages  \n**Negative is plotted upward.**\n\n```{r plotGrand, echo=FALSE}\n# plot grand averages\ngrand = read.delim(\"./5 waveforms/data/Data for grand averages_allelec.txt\")\n\ncondLine <- c(\"Black_gun_correct\" = \"dashed\",    # CRN is dashed\n              \"Black_tool_correct\" = \"dashed\", \n              \"White_gun_correct\" = \"dashed\", \n              \"White_tool_correct\" = \"dashed\",\n              \"Black_gun_incorrect\" = \"solid\",  # ERN is solid\n              \"Black_tool_incorrect\" = \"solid\", \n              \"White_gun_incorrect\" = \"solid\", \n              \"White_tool_incorrect\" = \"solid\")\n\n\ncondColors <- c(\"Black_gun_correct\" = \"dodgerblue\", \n                \"Black_tool_correct\" = \"blue\", \n                \"White_gun_correct\" = \"red\", \n                \"White_tool_correct\" = \"darkred\",\n                \"Black_gun_incorrect\" = \"dodgerblue\", \n                \"Black_tool_incorrect\" = \"blue\", \n                \"White_gun_incorrect\" = \"red\", \n                \"White_tool_incorrect\" = \"darkred\")\n\nERPline = geom_line(lwd=1.1,\n                    #linetype=plotCondition,\n                    aes(color = plotCondition, linetype = plotCondition))\n\n\nERNbox = annotate(\"rect\",\n                 xmin=25, xmax=125, ymin=-Inf, ymax=Inf, \n                 alpha=0,\n                 fill=\"#F0E0FF\",\n                 color=\"black\", \n                 linetype=\"dashed\") \n\nnone = element_blank() \n\n# average of all 9 electrodes\nggplot(data=grand, aes(Time, avgElec, group = plotCondition)) + \n  ERPline + \n  ERNbox + \n  theme_bw() + \n  theme(panel.grid.major.x = none, panel.grid.minor.x = none) +\n  scale_x_continuous(\"Time (ms)\", \n                     limits=c(-400, 500), \n                     expand=c(0,0),   # expand=c(0,0) removes extra space before & after data\n                     breaks=c(-400, -300, -200, -100, 0, 100, 200, 300, 400, 500)) +\n  geom_hline(yintercept=0) + # adds x axis\n  geom_vline(xintercept=0) +\n  scale_y_reverse(limits =c(10, -7.5)) +  # scale_y_reverse flips y axis\n  ylab(\"Amplitude (uV)\") +\n  scale_color_manual(values=condColors) +\n  scale_linetype_manual(values=condLine) +\n  ggtitle(\"Average of fronto-central electrodes\") +\n  theme(plot.title = element_text(hjust = 0.5)) # center title\n\n\n```\n  \nTo test the mean amplitude of the ERNs, a model was fitted with Race and Object as predictors. The intercept, slopes of Race and Object, and their interaction were allowed to vary by subject. The intercept was allowed to vary by Electrode nested within Subject. \n\nRace and Object were both effect coded. \n\n``` {r test, echo=F}\ndat = read.delim(\"./4 quantified data/ERN_noMiss_noArt_RTaccept_noBS.txt\")\nerrDat = dat %>% filter(Accuracy == \"incorrect\")\n\n# add effect codes for categorical variables\nerrDat$Race.e = NA\nerrDat$Race.e[errDat$Race == \"Black\"] = -1\nerrDat$Race.e[errDat$Race == \"White\"] = 1\n\nerrDat$Object.e = NA\nerrDat$Object.e[errDat$Object == \"gun\"] = -1\nerrDat$Object.e[errDat$Object == \"tool\"] = 1\n\n# model specified in \"6 ERN model specification.R\"\ngrand1 = lmer(MeanAmp ~ Race.e*Object.e + (Race.e*Object.e|Subject) + (1|Electrode:Subject), dat = errDat)\n```\n  \n**Random effects:**  \n``` {r grand1random, echo = FALSE}\nsummary(grand1)$varcor\n```\n\n**Fixed effects:**\n``` {r grand1fixed, echo = FALSE} \nround(summary(grand1)$coefficients, digits = 3)\n```\n\n### 2. Looking at the ERN over the course of the experiment\n##### - Each error occurs at original trial number\n\n**Slopes and estimates of lines are from the MLM, not fitted with OLS.  Negative is plotted downward.** \n\n``` {r trialLevel, echo = FALSE, warning = FALSE}\n# making dummy codes is redundant but comforting, so LET ME LIVE\nerrDat$Race.d = NA\nerrDat$Race.d[errDat$Race == \"Black\"] = 0\nerrDat$Race.d[errDat$Race == \"White\"] = 1\n\nerrDat$Object.d = NA\nerrDat$Object.d[errDat$Object == \"gun\"] = 0\nerrDat$Object.d[errDat$Object == \"tool\"] = 1\n\n# find slopes and intercepts with dummy coded model, trial (unscaled) is included\nplot1.d = lmer(MeanAmp ~ Race.d*Object.d*Trial + (Race.d*Object.d|Subject) + (1|Electrode:Subject), dat = errDat)\n\nparms <- fixef(plot1.d) # fixed parameters from model\nvcmat <- vcov(plot1.d) # variance/covariance matrix of fixed effects\n\n# First calculate slopes\n\n## each row of this matrix defines entries of parms that we want to combine:\nSTmat <- matrix(NA,4,8)\nSTmat[1,] <- c(rep(0,3),1,0,0,0,0) # slope for race = 0, object = 0 (black-gun)\nSTmat[2,] <- c(rep(0,3),1,0,0,1,0) # slope for race = 0, object = 1 (black-tool)\nSTmat[3,] <- c(rep(0,3),1,0,1,0,0) # slope for race = 1, object = 0 (white-gun)\nSTmat[4,] <- c(rep(0,3),1,0,1,1,1) # slope for race = 1, object = 1 (white-tool)\n\nSparest <- STmat %*% parms          # see above for notation\nSnewvc <- STmat %*% vcmat %*% t(STmat)\nSses <- sqrt(diag(Snewvc)) \n\nslopes = cbind(Sparest, Sses) %>% as.data.frame()\nnames(slopes) = c(\"Slope\", \"Slope_SE\")\n\n# Next calculate intercepts\n\n## each row of this matrix defines entries of parms that we want to combine:\nITmat <- matrix(NA,4,8)\nITmat[1,] <- c(1,0,0,0,0,rep(0,3)) # intercept for race = 0, object = 0 (black-gun)\nITmat[2,] <- c(1,0,1,0,0,rep(0,3)) # intercept for race = 0, object = 1 (black-tool)\nITmat[3,] <- c(1,1,0,0,0,rep(0,3)) # intercept for race = 1, object = 0 (white-gun)\nITmat[4,] <- c(1,1,0,0,1,rep(0,3)) # intercept for race = 1, object = 1 (white-tool)\n\nIparest <- ITmat %*% parms          # see above for notation\nInewvc <- ITmat %*% vcmat %*% t(ITmat)\nIses <- sqrt(diag(Inewvc)) \n\nintercepts = cbind(Iparest, Ises) %>% as.data.frame()\nnames(intercepts) = c(\"Intercept\", \"Intercept_SE\")\n\nforPlotting = cbind(slopes, intercepts)\n\n# label for understanding\nforPlotting$Condition = c(\"Black_gun\", \n                          \"Black_tool\",\n                          \"White_gun\",\n                          \"White_tool\")\n\n\n# BINGO -------------------------------------------------------------------\nggplot(errDat, aes(Trial, MeanAmp, alpha = Condition, color = Condition, shape = Condition)) +\n  geom_point() +\n  geom_abline(data = forPlotting, aes(intercept=Intercept, slope=Slope, color = Condition), size=1)+\n  labs(x = \"Trial\", y = \"Mean Amplitude\") +\n  scale_shape_manual(values=c(1,19,1,19)) +\n  scale_alpha_manual(values=c(.1,.1,.1,.1)) +\n  scale_color_manual(values=c(\"dodgerblue\", \"blue\", \"red\", \"darkred\")) +\n  theme_bw() +\n  scale_y_continuous(limits =c(-7.5, 10), expand=c(0,0)) +\n  scale_x_continuous(expand=c(0,0)) +\n  ggtitle(\"Trial is original trial number\") +\n  theme(plot.title = element_text(hjust = 0.5)) # center title\n```\n\n##### Simple slopes\n\nTrial is scaled to range from 0 to 10 (instead of 1 to 384) so that the betas associated with trial are a little bigger (but significance testing is unaffected by linear scaling, so the test statistics and p values will be the same as if we used the unscaled Trial variable).\n\n``` {r simple, echo = FALSE}\n# rescale trial\nerrDat$Trial.begin = (errDat$Trial-1)/3.83\n# shift trial to look at fixed effects at middle and end of task as well\nerrDat$Trial.middle = errDat$Trial.begin - 5\nerrDat$Trial.end = errDat$Trial.begin - 10\n\n# find slopes with dummy coded model, trial is scaled\nbegin.d <- lmer(MeanAmp ~ Race.d*Object.d*Trial.begin + (Race.d*Object.d|Subject) + (1|Electrode:Subject), dat = errDat)\n\nparms <- fixef(begin.d) # fixed parameters from model\nvcmat <- vcov(begin.d) # variance/covariance matrix of fixed effects\n\n## each row of this matrix defines entries of parms that we want to combine:\nTmat <- matrix(NA,4,8)\nTmat[1,] <- c(rep(0,3),1,0,0,0,0) # weights for estimates for current = 0, previous = 0 (current compat-previous compat)\nTmat[2,] <- c(rep(0,3),1,0,0,1,0) # weights for estimates for current = 0, previous = 1 (current compat-previous incompat)\nTmat[3,] <- c(rep(0,3),1,0,1,0,0) # weights for estimates for current = 1, previous = 0 (current incompat-previous compat)\nTmat[4,] <- c(rep(0,3),1,0,1,1,1) # weights for estimates for current = 1, previous = 1 (current incompat-previous incompat)\n\nparest <- Tmat %*% parms          # see above for notation\nnewvc <- Tmat %*% vcmat %*% t(Tmat)\nses <- sqrt(diag(newvc)) \n\n## final results\nfin = cbind(parest, ses) %>% as.data.frame()\nnames(fin) = c(\"est\", \"ses\")\n\n# to calculate 95% CI intervals, lower bound = m - 2*SE, upper bound = m + 2*SE\n\nfin$lbnd = fin$est - 2*fin$ses\nfin$ubnd = fin$est + 2*fin$ses\n\nfin = format(fin, digits = 3)\n\n# relabel for understanding\nfin$Race = c(\"Black\", \"Black\", \"White\", \"White\")\nfin$Object = c(\"gun\", \"tool\", \"gun\", \"tool\")\nfin$Color = c(\"light blue\", \"dark blue\", \"light red\", \"dark red\")\n\nfin = rename(fin, Estimate = est, SE = ses, ci95_lower = lbnd, ci95_upper = ubnd)\n\n# display\nfin\n```  \n\n#### Model output\nThe intercept, slopes of current and previous trial condition and their interaction are allowed to vary by subject. *Categorical variables are effect coded.*   \n  \nTrial is scaled to range from 0 to 10.  \n\n``` {r begin, echo = FALSE}\n# same model, but with effect coding\nbegin.e = lmer(MeanAmp ~ Race.e*Object.e*Trial.begin + (Race.e*Object.e|Subject) + (1|Electrode:Subject), dat = errDat)\n```\n  \n**Random effects:**  \n``` {r beginrandom, echo = FALSE}\nsummary(begin.e)$varcor\n```\n\n**Fixed effects:**\n``` {r beginfixed, echo = FALSE} \nround(summary(begin.e)$coefficients[c(1:3,5),1:5], digits = 4)\nround(summary(begin.e)$coefficients[c(4,6:8),1:5], digits = 3)\n```\n\n### 3. Looking at the ERN over the course of the experiment\n##### - Each error is order for each subject, then centered for each subject\n  \n**Slopes and estimates of lines are from the MLM, not fitted with OLS.  Negative is plotted downward.** \n  \n``` {r subcentered, echo=F, warning=F}\ntrialOrderDat = NULL\nfor (i in unique(dat$Subject)) {\n  # take error trials, renumber them by order\n  err = dat[dat$Subject == i & dat$Accuracy == \"incorrect\",] %>% \n    filter(!is.na(Trial))\n  err$TrialOrder = rep(1:length(unique(err$Trial)), each = 9)\n  \n  trialOrderDat = rbind(trialOrderDat, err)\n}\n\n# center ordered trial variable for each subject\nfor (i in unique(dat$Subject)) {\n  numTrial = max(trialOrderDat$TrialOrder[trialOrderDat$Subject == i])\n  trialOrderDat$TrialOrder.c[trialOrderDat$Subject == i] = trialOrderDat$TrialOrder[trialOrderDat$Subject == i] - numTrial/2\n}\n\n# fit model to plot simple slopes\nplot2.d = lmer(MeanAmp ~ Race*Object*TrialOrder.c + (Race*Object|Subject) + (1|Electrode:Subject), dat = trialOrderDat)\n\nparms <- fixef(plot2.d) # fixed parameters from model\nvcmat <- vcov(plot2.d) # variance/covariance matrix of fixed effects\n\n# First calculate slopes\n\n## each row of this matrix defines entries of parms that we want to combine:\nSTmat <- matrix(NA,4,8)\nSTmat[1,] <- c(rep(0,3),1,0,0,0,0) # slope for race = 0, object = 0 (black-gun)\nSTmat[2,] <- c(rep(0,3),1,0,0,1,0) # slope for race = 0, object = 1 (black-tool)\nSTmat[3,] <- c(rep(0,3),1,0,1,0,0) # slope for race = 1, object = 0 (white-gun)\nSTmat[4,] <- c(rep(0,3),1,0,1,1,1) # slope for race = 1, object = 1 (white-tool)\n\nSparest <- STmat %*% parms          # see above for notation\nSnewvc <- STmat %*% vcmat %*% t(STmat)\nSses <- sqrt(diag(Snewvc)) \n\nslopes = cbind(Sparest, Sses) %>% as.data.frame()\nnames(slopes) = c(\"Slope\", \"Slope_SE\")\n\n# Next calculate intercepts\n\n## each row of this matrix defines entries of parms that we want to combine:\nITmat <- matrix(NA,4,8)\nITmat[1,] <- c(1,0,0,0,0,rep(0,3)) # intercept for race = 0, object = 0 (black-gun)\nITmat[2,] <- c(1,0,1,0,0,rep(0,3)) # intercept for race = 0, object = 1 (black-tool)\nITmat[3,] <- c(1,1,0,0,0,rep(0,3)) # intercept for race = 1, object = 0 (white-gun)\nITmat[4,] <- c(1,1,0,0,1,rep(0,3)) # intercept for race = 1, object = 1 (white-tool)\n\nIparest <- ITmat %*% parms          # see above for notation\nInewvc <- ITmat %*% vcmat %*% t(ITmat)\nIses <- sqrt(diag(Inewvc)) \n\nintercepts = cbind(Iparest, Ises) %>% as.data.frame()\nnames(intercepts) = c(\"Intercept\", \"Intercept_SE\")\n\nforPlotting = cbind(slopes, intercepts)\n\n# label for understanding\nforPlotting$Condition = c(\"Black_gun\", \n                          \"Black_tool\",\n                          \"White_gun\",\n                          \"White_tool\")\n\n\n# BINGO -------------------------------------------------------------------\nggplot(trialOrderDat, aes(TrialOrder.c, MeanAmp, alpha = Condition, color = Condition, shape = Condition)) +\n  geom_point() +\n  geom_abline(data = forPlotting, aes(intercept=Intercept, slope=Slope, color = Condition), size=1)+\n  labs(x = \"Trial\", y = \"Mean Amplitude\") +\n  scale_shape_manual(values=c(1,19,1,19)) +\n  scale_alpha_manual(values=c(.1,.1,.1,.1)) +\n  scale_color_manual(values=c(\"dodgerblue\", \"blue\", \"red\", \"darkred\")) +\n  theme_bw() +\n  scale_y_continuous(limits =c(-7.5, 10), expand=c(0,0)) +\n  scale_x_continuous(expand=c(0,0)) +\n  ggtitle(\"Errors are ordered and subject-centered\") +\n  theme(plot.title = element_text(hjust = 0.5)) # center title\n\n```\n\n##### Simple slopes\n\n``` {r simple2, echo = FALSE}\n\n# model is already specified above\n\n## each row of this matrix defines entries of parms that we want to combine:\nTmat <- matrix(NA,4,8)\nTmat[1,] <- c(rep(0,3),1,0,0,0,0) # weights for estimates for current = 0, previous = 0 (current compat-previous compat)\nTmat[2,] <- c(rep(0,3),1,0,0,1,0) # weights for estimates for current = 0, previous = 1 (current compat-previous incompat)\nTmat[3,] <- c(rep(0,3),1,0,1,0,0) # weights for estimates for current = 1, previous = 0 (current incompat-previous compat)\nTmat[4,] <- c(rep(0,3),1,0,1,1,1) # weights for estimates for current = 1, previous = 1 (current incompat-previous incompat)\n\nparest <- Tmat %*% parms          # see above for notation\nnewvc <- Tmat %*% vcmat %*% t(Tmat)\nses <- sqrt(diag(newvc)) \n\n## final results\nfin = cbind(parest, ses) %>% as.data.frame()\nnames(fin) = c(\"est\", \"ses\")\n\n# to calculate 95% CI intervals, lower bound = m - 2*SE, upper bound = m + 2*SE\n\nfin$lbnd = fin$est - 2*fin$ses\nfin$ubnd = fin$est + 2*fin$ses\n\nfin = format(fin, digits = 3)\n\n# relabel for understanding\nfin$Race = c(\"Black\", \"Black\", \"White\", \"White\")\nfin$Object = c(\"gun\", \"tool\", \"gun\", \"tool\")\nfin$Color = c(\"light blue\", \"dark blue\", \"light red\", \"dark red\")\n\nfin = rename(fin, Estimate = est, SE = ses, ci95_lower = lbnd, ci95_upper = ubnd)\n\n# display\nfin\n```  \n\n#### Model output\nThe intercept, slopes of current and previous trial condition and their interaction are allowed to vary by subject. *Categorical variables are effect coded.*   \n  \nFor each subject, error trials are numbered (in order) and centered.   \n\n``` {r sc, echo = FALSE}\n# same model, but with effect coding\n# add effect codes for categorical variables\ntrialOrderDat$Race.e = NA\ntrialOrderDat$Race.e[trialOrderDat$Race == \"Black\"] = -1\ntrialOrderDat$Race.e[trialOrderDat$Race == \"White\"] = 1\n\ntrialOrderDat$Object.e = NA\ntrialOrderDat$Object.e[trialOrderDat$Object == \"gun\"] = -1\ntrialOrderDat$Object.e[trialOrderDat$Object == \"tool\"] = 1\n\nsubcentered = lmer(MeanAmp ~ Race.e*Object.e*TrialOrder.c + (Race.e*Object.e|Subject) + (1|Electrode:Subject), dat = trialOrderDat)\n```\n  \n**Random effects:**  \n``` {r sc_random, echo = FALSE}\nsummary(subcentered)$varcor\n```\n\n**Fixed effects:**\n``` {r sc_fixed, echo = FALSE} \nround(summary(subcentered)$coefficients[c(1:3,5),1:5], digits = 3)\nround(summary(subcentered)$coefficients[c(4,6:8),1:5], digits = 3)\n```\n\n",
    "created" : 1489017870971.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "900628895",
    "id" : "DB0B419B",
    "lastKnownWriteTime" : 1491253026,
    "last_content_update" : 1491253026050,
    "path" : "~/Documents/Projects/6 MLM Psychophys paper/EFbias data/ERN_EFbias.Rmd",
    "project_path" : "ERN_EFbias.Rmd",
    "properties" : {
        "chunk_output_type" : "console"
    },
    "relative_order" : 13,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}