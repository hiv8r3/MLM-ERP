---
title: ERN from EF bias
author: Hannah, 4/18/2017
output:
  html_document:
    highlight: pygments
    theme: cerulean
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(width=140)
require(dplyr)
require(ggplot2)
require(lme4)
require(lmerTest)
require(colorspace)
require(grid)
```

**Major changes: Changed models to cross-classfied models (grouping variables are subject and electrode, where electrode is *not* nested within subject.**  

Data from previously processed EEG files from CU and MU were used. Before I got them, the following was done:  

1) CNT file was merged with dat file to add response latency and accuracy information to CNT file  
2) CNT was re-referenced to average mastoids reference  
3) Blinks were corrected for  
4) A filter was applied (need to look up the settings for that)  
5) Files were response-locked, with an epoch of -400 to 500  

I subsequently:  

1) Baseline corrected EEG files (using a baseline of -400 to -200)  
2) Performed an automatic artifact rejected procedure (trials with +- 75 uV were rejected, only using 9 electrodes of interest as the criteria)  

Trials were included if:  
1) The RT was between 200 and 500 ms  
2) A response was made (i.e., no miss trials)  
3) The trial wasn't rejected in artifact rejection procedure  

The following subjects were excluded:    
- 1040 (doesn't have full number of trials)  
- 2023 (problems with EEG data)  
- 2077 (problems with EEG data)  
- 2089 (problems with EEG data)  
- 2151 (problems with EEG data)  
- 2157 (problems with EEG data)  
- 2181 (problems with EEG data)  
- 2187 (doesn't have full number of trials)  

Each subject did 384 experimental trials (prime-only trials were also included but not in the 384).  

FZ, F3, F4, FCZ, FC3, FC4, C3, CZ, C4 (9 electrodes) were included.

**Total sample is 134 subjects, 60 from CU and 74 from MU.**


### 1. Examine correlation between subjects' ERN mean amplitude and total number of errors

*All conditions together:*  
``` {r correl, echo=FALSE}
dat = read.delim("./4 quantified data/ERN_noMiss_noArt_RTaccept_noBS.txt") %>% filter(Accuracy == "incorrect")

errors = read.delim("ErrorsPerCondition.txt")
errors$Total = errors$WT + errors$WG + errors$BT + errors$BG

# All errors together -----------------------------------------------------

dat.sum = select(dat, Subject, MeanAmp) %>% 
  group_by(Subject) %>% 
  summarise_each(funs(mean(., na.rm=TRUE))) %>% 
  as.data.frame()

forCor = cbind(errors, dat.sum)

ggplot(aes(Total, MeanAmp), data = forCor) +
  geom_point() +
  geom_smooth(method="lm") +
  xlab("Total number of errors") + 
  ylab("ERN mean amplitude") +
  ggtitle("All conditions") +
  theme(plot.title = element_text(hjust = 0.5))

m = cor.test(forCor$Total, forCor$MeanAmp)

data.frame(pearsons.r = m$estimate, pvalue = m$p.value)
```

*By condition separately:*
``` {r correl2, echo=F}
# Just Black-tool errors --------------------------------------------------
BT = filter(dat, Condition == "Black_tool") %>% 
  select(Subject, MeanAmp) %>% 
  group_by(Subject) %>% 
  summarise_each(funs(mean(., na.rm=TRUE))) %>% 
  as.data.frame()

forCorBT = cbind(errors, BT)

bt = cor.test(forCorBT$BT, forCorBT$MeanAmp)

# Just Black-gun errors --------------------------------------------------
BG = filter(dat, Condition == "Black_gun") %>% 
  select(Subject, MeanAmp) %>% 
  group_by(Subject) %>% 
  summarise_each(funs(mean(., na.rm=TRUE))) %>% 
  as.data.frame()

forCorBG = cbind(errors, BG)

bg = cor.test(forCorBG$BG, forCorBG$MeanAmp)

# Just White-tool errors --------------------------------------------------
WT = filter(dat, Condition == "White_tool") %>% 
  select(Subject, MeanAmp) %>% 
  group_by(Subject) %>% 
  summarise_each(funs(mean(., na.rm=TRUE))) %>% 
  as.data.frame()

forCorWT = cbind(errors, WT)

wt = cor.test(forCorWT$WT, forCorWT$MeanAmp)

# Just White-gun errors --------------------------------------------------
WG = filter(dat, Condition == "White_gun") %>% 
  select(Subject, MeanAmp) %>% 
  group_by(Subject) %>% 
  summarise_each(funs(mean(., na.rm=TRUE))) %>% 
  as.data.frame()

forCorWG = cbind(errors, WG)

wg = cor.test(forCorWG$WG, forCorWG$MeanAmp)

display = 
  rbind(data.frame(condition = "Black-gun", pearsons.r = bg$estimate, pvalue = bg$p.value),
      data.frame(condition = "Black-tool", pearsons.r = bt$estimate, pvalue = bt$p.value),
      data.frame(condition = "White-gun", pearsons.r = wg$estimate, pvalue = wg$p.value),
      data.frame(condition = "White-tool", pearsons.r = wt$estimate, pvalue = wt$p.value))

display$pearsons.r = round(display$pearsons.r, digits = 3)
display$pvalue = round(display$pvalue, digits = 3)
rownames(display) = NULL
display

# Graph all together -----------------------

datcond = select(dat, -Race, -Object, -Accuracy, -Electrode, -Trial) %>% 
  group_by(Subject, Condition) %>% 
  summarise_each(funs(mean(., na.rm=TRUE))) %>% 
  as.data.frame()

errors = rename(errors, White_tool = WT,
                Black_tool = BT,
                White_gun = WG,
                Black_gun = BG)

for (k in unique(datcond$Subject)) {
  datcond$numErr[datcond$Subject == k][1] = errors[errors$Subject == k, 5] #Black-gun
  datcond$numErr[datcond$Subject == k][2] = errors[errors$Subject == k, 4] #Black-tool
  datcond$numErr[datcond$Subject == k][3] = errors[errors$Subject == k, 3] #White-gun
  datcond$numErr[datcond$Subject == k][4] = errors[errors$Subject == k, 2] #White-tool
}

ggplot(aes(numErr, MeanAmp), data = datcond) + #2174 is outlier in Black-Gun trials
  facet_wrap(~Condition) +
  geom_point() +
  geom_smooth(method="lm") +
  xlab("Total number of errors") +
  ylab("ERN mean amplitude (uV)")

ggsave("Figure_CorrelationBetweenNumErrorsAndERN.tiff")

```

### 2. ERN/CRN grand averages  
**Negative is plotted upward.**

```{r plotGrand, echo=FALSE}
# plot grand averages
grand = read.delim("./5 waveforms/data/Data for grand averages_allelec.txt")

condLine <- c("Black_gun_correct" = "dashed",    # CRN is dashed
              "Black_tool_correct" = "dashed", 
              "White_gun_correct" = "dashed", 
              "White_tool_correct" = "dashed",
              "Black_gun_incorrect" = "solid",  # ERN is solid
              "Black_tool_incorrect" = "solid", 
              "White_gun_incorrect" = "solid", 
              "White_tool_incorrect" = "solid")


condColors <- c("Black_gun_correct" = "dodgerblue", 
                "Black_tool_correct" = "blue", 
                "White_gun_correct" = "red", 
                "White_tool_correct" = "darkred",
                "Black_gun_incorrect" = "dodgerblue", 
                "Black_tool_incorrect" = "blue", 
                "White_gun_incorrect" = "red", 
                "White_tool_incorrect" = "darkred")

ERPline = geom_line(lwd=1.1,
                    #linetype=plotCondition,
                    aes(color = plotCondition, linetype = plotCondition))


ERNbox = annotate("rect",
                 xmin=25, xmax=125, ymin=-Inf, ymax=Inf, 
                 alpha=0,
                 fill="#F0E0FF",
                 color="black", 
                 linetype="dashed") 

none = element_blank() 

# average of all 9 electrodes
ggplot(data=grand, aes(Time, avgElec, group = plotCondition)) + 
  ERPline + 
  ERNbox + 
  theme_bw() + 
  theme(panel.grid.major.x = none, panel.grid.minor.x = none) +
  scale_x_continuous("Time (ms)", 
                     limits=c(-400, 500), 
                     expand=c(0,0),   # expand=c(0,0) removes extra space before & after data
                     breaks=c(-400, -300, -200, -100, 0, 100, 200, 300, 400, 500)) +
  geom_hline(yintercept=0) + # adds x axis
  geom_vline(xintercept=0) +
  scale_y_reverse(limits =c(10, -7.5)) +  # scale_y_reverse flips y axis
  ylab("Amplitude (uV)") +
  scale_color_manual(values=condColors) +
  scale_linetype_manual(values=condLine) +
  ggtitle("Average of fronto-central electrodes") +
  theme(plot.title = element_text(hjust = 0.5),# center title
        axis.title = element_text(size = 20),
        axis.text.y = element_text(size = 16),
        axis.text.x = element_text(size = 12),
        #legend.title = element_text(size = 20),
        #legend.text = element_text(size = 16),
        strip.text = element_text(size = 16)) 

ggsave("EFbias data/GrandAverage_ERN.tiff")
```
  
To test the mean amplitude of the ERNs, a model was fitted with Race and Object as predictors, with ERN mean amplitude as the DV (correct trials are not included). The intercept, slopes of Race and Object, and their interaction were allowed to vary by subject. The intercept was allowed to vary by Electrode (*not* nested within Subject). 

Race and Object were both effect coded. 

``` {r test, echo=F}
errDat = dat %>% filter(Accuracy == "incorrect")

# add effect codes for categorical variables
errDat$Race.e = NA
errDat$Race.e[errDat$Race == "Black"] = -1
errDat$Race.e[errDat$Race == "White"] = 1

errDat$Object.e = NA
errDat$Object.e[errDat$Object == "gun"] = -1
errDat$Object.e[errDat$Object == "tool"] = 1

# model specified in "6 ERN model specification.R"
grand1 = lmer(MeanAmp ~ Race.e*Object.e + (Race.e*Object.e|Subject) + (1|Electrode), dat = errDat)

```
  
**Random effects:**  
``` {r grand1random, echo = FALSE}
summary(grand1)$varcor
```

**Fixed effects:**
``` {r grand1fixed, echo = FALSE} 
round(summary(grand1)$coefficients, digits = 3)
```


### 3. Looking at the ERN over the course of the experiment: Time-on-task
  
**Slopes and estimates of lines are from the MLM, not fitted with OLS.  Negative is plotted downward.** 
  
``` {r tot, echo=F, warning=F}
# fit model to plot simple slopes
plot2.d = lmer(MeanAmp ~ Race*Object*Trial + (Race*Object|Subject) + (1|Electrode), dat = errDat)

parms <- fixef(plot2.d) # fixed parameters from model
vcmat <- vcov(plot2.d) # variance/covariance matrix of fixed effects

# First calculate slopes

## each row of this matrix defines entries of parms that we want to combine:
STmat <- matrix(NA,4,8)
STmat[1,] <- c(rep(0,3),1,0,0,0,0) # slope for race = 0, object = 0 (black-gun)
STmat[2,] <- c(rep(0,3),1,0,0,1,0) # slope for race = 0, object = 1 (black-tool)
STmat[3,] <- c(rep(0,3),1,0,1,0,0) # slope for race = 1, object = 0 (white-gun)
STmat[4,] <- c(rep(0,3),1,0,1,1,1) # slope for race = 1, object = 1 (white-tool)

Sparest <- STmat %*% parms          # see above for notation
Snewvc <- STmat %*% vcmat %*% t(STmat)
Sses <- sqrt(diag(Snewvc)) 

slopes = cbind(Sparest, Sses) %>% as.data.frame()
names(slopes) = c("Slope", "Slope_SE")

# Next calculate intercepts

## each row of this matrix defines entries of parms that we want to combine:
ITmat <- matrix(NA,4,8)
ITmat[1,] <- c(1,0,0,0,0,rep(0,3)) # intercept for race = 0, object = 0 (black-gun)
ITmat[2,] <- c(1,0,1,0,0,rep(0,3)) # intercept for race = 0, object = 1 (black-tool)
ITmat[3,] <- c(1,1,0,0,0,rep(0,3)) # intercept for race = 1, object = 0 (white-gun)
ITmat[4,] <- c(1,1,0,0,1,rep(0,3)) # intercept for race = 1, object = 1 (white-tool)

Iparest <- ITmat %*% parms          # see above for notation
Inewvc <- ITmat %*% vcmat %*% t(ITmat)
Ises <- sqrt(diag(Inewvc)) 

intercepts = cbind(Iparest, Ises) %>% as.data.frame()
names(intercepts) = c("Intercept", "Intercept_SE")

forPlotting = cbind(slopes, intercepts)

# label for understanding
forPlotting$Condition = c("Black_gun", 
                          "Black_tool",
                          "White_gun",
                          "White_tool")


# BINGO -------------------------------------------------------------------
ggplot(dat, aes(Trial, MeanAmp, alpha = Condition, color = Condition, shape = Condition)) +
  geom_point() +
  geom_abline(data = forPlotting, aes(intercept=Intercept, slope=Slope, color = Condition), size=1)+
  labs(x = "Trial", y = "ERN mean amplitude (uV)") +
  scale_shape_manual(values=c(1,19,1,19)) +
  scale_alpha_manual(values=c(.1,.1,.1,.1)) +
  scale_color_manual(values=c("dodgerblue", "blue", "red", "darkred")) +
  theme_bw() +
  scale_y_continuous(limits =c(-7.5, 10), expand=c(0,0)) +
  scale_x_continuous(expand=c(0,0)) +
  ggtitle("Time-on-task") +
  theme(plot.title = element_text(hjust = 0.5),# center title
        axis.title = element_text(size = 20),
        axis.text.y = element_text(size = 16),
        axis.text.x = element_text(size = 12),
        #legend.title = element_text(size = 20),
        #legend.text = element_text(size = 16),
        strip.text = element_text(size = 16)) 

ggsave("EFbias data/SimpleSlopes_TimeOnTask.tiff")
```

##### Simple slopes

Trial number is rescaled to range from 0 to 10.
``` {r simple3, echo = FALSE}
errDat$Trial.s = errDat$Trial/38.4

plot2.d = lmer(MeanAmp ~ Race*Object*Trial.s + (Race*Object|Subject) + (1|Electrode), dat = errDat)

parms <- fixef(plot2.d) # fixed parameters from model
vcmat <- vcov(plot2.d) # variance/covariance matrix of fixed effects

## each row of this matrix defines entries of parms that we want to combine:
Tmat <- matrix(NA,4,8)
Tmat[1,] <- c(rep(0,3),1,0,0,0,0) # weights for estimates for race = 0, object = 0 
Tmat[2,] <- c(rep(0,3),1,0,0,1,0) # weights for estimates for race = 0, object = 1 
Tmat[3,] <- c(rep(0,3),1,0,1,0,0) # weights for estimates for race = 1, object = 0 
Tmat[4,] <- c(rep(0,3),1,0,1,1,1) # weights for estimates for race = 1, object = 1 

parest <- Tmat %*% parms          # see above for notation
newvc <- Tmat %*% vcmat %*% t(Tmat)
ses <- sqrt(diag(newvc)) 

## final results
fin = cbind(parest, ses) %>% as.data.frame()
names(fin) = c("est", "ses")

# to calculate 95% CI intervals, lower bound = m - 2*SE, upper bound = m + 2*SE

fin$lbnd = fin$est - 2*fin$ses
fin$ubnd = fin$est + 2*fin$ses

fin = format(fin, digits = 3)

# relabel for understanding
fin$Race = c("Black", "Black", "White", "White")
fin$Object = c("gun", "tool", "gun", "tool")
fin$Color = c("light blue", "dark blue", "light red", "dark red")

fin = rename(fin, Estimate = est, SE = ses, ci95_lower = lbnd, ci95_upper = ubnd)

# display
fin
```  

#### Model output
The intercept, slopes of Race and Object and their interaction are allowed to vary by subject. The intercept is additionally allowed to vary by electrode (*not* nested within subject). *Categorical variables are effect coded.*   
  
Trial is rescaled to range from 0 to 10. Each data point corresponds to ERN mean amplitude following an error, with the error's original trial number on the x-axis. This spacing maintains time-on-task as the x variable. Fixed effects of Race, Object, and their interaction are estimated at the beginning of the task.

``` {r tot2, echo = FALSE}
# same model, but with effect coding
tot = lmer(MeanAmp ~ Race.e*Object.e*Trial.s + (Race.e*Object.e|Subject) + (1|Electrode), dat = errDat)
```
  
**Random effects:**  
``` {r tot_random, echo = FALSE}
summary(tot)$varcor
```

**Fixed effects:**
``` {r tot_fixed, echo = FALSE} 
round(summary(tot)$coefficients[c(1:3,5),1:5], digits = 4)
round(summary(tot)$coefficients[c(4,6:8),1:5], digits = 3)
```

### 4. Looking at the ERN over the course of the experiment: Ordered errors
##### - Each error is ordered for each subject (i.e., error #1 for subject 10 and error #1 for subject 20 now have the same x-value, even if it happened on trial 12 for subject 10 and trial 50 for subject 20). Trial-type is ignored when ordering errors.
  
**Slopes and estimates of lines are from the MLM, not fitted with OLS.  Negative is plotted downward.** 
  
``` {r subord, echo=F, warning=F}
trialOrderDat = NULL
for (i in unique(dat$Subject)) {
  # take error trials, renumber them by order
  err = dat[dat$Subject == i & dat$Accuracy == "incorrect",] %>% 
    filter(!is.na(Trial))
  err$TrialOrder = rep(1:length(unique(err$Trial)), each = 9)
  
  trialOrderDat = rbind(trialOrderDat, err)
}

# fit model to plot simple slopes
plot3.d = lmer(MeanAmp ~ Race*Object*TrialOrder + (Race*Object|Subject) + (1|Electrode), dat = trialOrderDat)

parms <- fixef(plot3.d) # fixed parameters from model
vcmat <- vcov(plot3.d) # variance/covariance matrix of fixed effects

# First calculate slopes

## each row of this matrix defines entries of parms that we want to combine:
STmat <- matrix(NA,4,8)
STmat[1,] <- c(rep(0,3),1,0,0,0,0) # slope for race = 0, object = 0 (black-gun)
STmat[2,] <- c(rep(0,3),1,0,0,1,0) # slope for race = 0, object = 1 (black-tool)
STmat[3,] <- c(rep(0,3),1,0,1,0,0) # slope for race = 1, object = 0 (white-gun)
STmat[4,] <- c(rep(0,3),1,0,1,1,1) # slope for race = 1, object = 1 (white-tool)

Sparest <- STmat %*% parms          # see above for notation
Snewvc <- STmat %*% vcmat %*% t(STmat)
Sses <- sqrt(diag(Snewvc)) 

slopes = cbind(Sparest, Sses) %>% as.data.frame()
names(slopes) = c("Slope", "Slope_SE")

# Next calculate intercepts

## each row of this matrix defines entries of parms that we want to combine:
ITmat <- matrix(NA,4,8)
ITmat[1,] <- c(1,0,0,0,0,rep(0,3)) # intercept for race = 0, object = 0 (black-gun)
ITmat[2,] <- c(1,0,1,0,0,rep(0,3)) # intercept for race = 0, object = 1 (black-tool)
ITmat[3,] <- c(1,1,0,0,0,rep(0,3)) # intercept for race = 1, object = 0 (white-gun)
ITmat[4,] <- c(1,1,0,0,1,rep(0,3)) # intercept for race = 1, object = 1 (white-tool)

Iparest <- ITmat %*% parms          # see above for notation
Inewvc <- ITmat %*% vcmat %*% t(ITmat)
Ises <- sqrt(diag(Inewvc)) 

intercepts = cbind(Iparest, Ises) %>% as.data.frame()
names(intercepts) = c("Intercept", "Intercept_SE")

forPlotting = cbind(slopes, intercepts)

# label for understanding
forPlotting$Condition = c("Black_gun", 
                          "Black_tool",
                          "White_gun",
                          "White_tool")


# BINGO -------------------------------------------------------------------
ggplot(trialOrderDat, aes(TrialOrder, MeanAmp, alpha = Condition, color = Condition, shape = Condition)) +
  geom_point() +
  geom_abline(data = forPlotting, aes(intercept=Intercept, slope=Slope, color = Condition), size=1)+
  labs(x = "Error number", y = "ERN mean amplitude (uV)") +
  scale_shape_manual(values=c(1,19,1,19)) +
  scale_alpha_manual(values=c(.1,.1,.1,.1)) +
  scale_color_manual(values=c("dodgerblue", "blue", "red", "darkred")) +
  theme_bw() +
  scale_y_continuous(limits =c(-7.5, 10), expand=c(0,0)) +
  scale_x_continuous(expand=c(0,0)) +
  ggtitle("Errors are ordered") +
  theme(plot.title = element_text(hjust = 0.5)) # center title

```

##### Simple slopes

Error order number is rescaled to range from 0 to 10. 
``` {r simple4, echo = FALSE}
trialOrderDat$TrialOrder.s = trialOrderDat$TrialOrder/14.1

plot4.d = lmer(MeanAmp ~ Race*Object*TrialOrder.s + (Race*Object|Subject) + (1|Electrode), dat = trialOrderDat)

parms <- fixef(plot4.d) # fixed parameters from model
vcmat <- vcov(plot4.d) # variance/covariance matrix of fixed effects

## each row of this matrix defines entries of parms that we want to combine:
Tmat <- matrix(NA,4,8)
Tmat[1,] <- c(rep(0,3),1,0,0,0,0) # weights for estimates for race = 0, object = 0 (Black-gun)
Tmat[2,] <- c(rep(0,3),1,0,0,1,0) # weights for estimates for race = 0, object = 1 (Black-tool)
Tmat[3,] <- c(rep(0,3),1,0,1,0,0) # weights for estimates for race = 1, object = 0 (White-gun)
Tmat[4,] <- c(rep(0,3),1,0,1,1,1) # weights for estimates for race = 1, object = 1 (White-tool)

parest <- Tmat %*% parms          # see above for notation
newvc <- Tmat %*% vcmat %*% t(Tmat)
ses <- sqrt(diag(newvc)) 

## final results
fin = cbind(parest, ses) %>% as.data.frame()
names(fin) = c("est", "ses")

# to calculate 95% CI intervals, lower bound = m - 2*SE, upper bound = m + 2*SE

fin$lbnd = fin$est - 2*fin$ses
fin$ubnd = fin$est + 2*fin$ses

fin = format(fin, digits = 3)

# relabel for understanding
fin$Race = c("Black", "Black", "White", "White")
fin$Object = c("gun", "tool", "gun", "tool")
fin$Color = c("light blue", "dark blue", "light red", "dark red")

fin = rename(fin, Estimate = est, SE = ses, ci95_lower = lbnd, ci95_upper = ubnd)

# display
fin
```  

#### Model output
The intercept, slopes of Race and Object and their interaction are allowed to vary by subject. Additionally, the intercept is allowed to vary by Electrode. *Categorical variables are effect coded.*   
  
For each subject, error trials are numbered (in order) and rescaled to range from 0 to 10.   

``` {r so, echo = FALSE}
# same model, but with effect coding
# add effect codes for categorical variables
trialOrderDat$Race.e = NA
trialOrderDat$Race.e[trialOrderDat$Race == "Black"] = -1
trialOrderDat$Race.e[trialOrderDat$Race == "White"] = 1

trialOrderDat$Object.e = NA
trialOrderDat$Object.e[trialOrderDat$Object == "gun"] = -1
trialOrderDat$Object.e[trialOrderDat$Object == "tool"] = 1

subord = lmer(MeanAmp ~ Race.e*Object.e*TrialOrder.s + (Race.e*Object.e|Subject) + (1|Electrode), dat = trialOrderDat)
```
  
**Random effects:**  
``` {r so_random, echo = FALSE}
summary(subord)$varcor
```

**Fixed effects:**
``` {r so_fixed, echo = FALSE} 
round(summary(subord)$coefficients[c(1:3,5),1:5], digits = 4)
round(summary(subord)$coefficients[c(4,6:8),1:5], digits = 3)
```

### 5. Looking at the ERN over the course of the experiment: Ordered errors, centered by subject
##### - Each error is ordered for each subject, then centered for each subject
  
**Slopes and estimates of lines are from the MLM, not fitted with OLS.  Negative is plotted downward.** 
  
``` {r subcentered, echo=F, warning=F}

# center ordered trial variable for each subject
for (i in unique(dat$Subject)) {
  numTrial = max(trialOrderDat$TrialOrder[trialOrderDat$Subject == i])
  trialOrderDat$TrialOrder.c[trialOrderDat$Subject == i] = trialOrderDat$TrialOrder[trialOrderDat$Subject == i] - numTrial/2
}

# fit model to plot simple slopes
plot5.d = lmer(MeanAmp ~ Race*Object*TrialOrder.c + (Race*Object|Subject) + (1|Electrode), dat = trialOrderDat)

parms <- fixef(plot5.d) # fixed parameters from model
vcmat <- vcov(plot5.d) # variance/covariance matrix of fixed effects

# First calculate slopes

## each row of this matrix defines entries of parms that we want to combine:
STmat <- matrix(NA,4,8)
STmat[1,] <- c(rep(0,3),1,0,0,0,0) # slope for race = 0, object = 0 (black-gun)
STmat[2,] <- c(rep(0,3),1,0,0,1,0) # slope for race = 0, object = 1 (black-tool)
STmat[3,] <- c(rep(0,3),1,0,1,0,0) # slope for race = 1, object = 0 (white-gun)
STmat[4,] <- c(rep(0,3),1,0,1,1,1) # slope for race = 1, object = 1 (white-tool)

Sparest <- STmat %*% parms          # see above for notation
Snewvc <- STmat %*% vcmat %*% t(STmat)
Sses <- sqrt(diag(Snewvc)) 

slopes = cbind(Sparest, Sses) %>% as.data.frame()
names(slopes) = c("Slope", "Slope_SE")

# Next calculate intercepts

## each row of this matrix defines entries of parms that we want to combine:
ITmat <- matrix(NA,4,8)
ITmat[1,] <- c(1,0,0,0,0,rep(0,3)) # intercept for race = 0, object = 0 (black-gun)
ITmat[2,] <- c(1,0,1,0,0,rep(0,3)) # intercept for race = 0, object = 1 (black-tool)
ITmat[3,] <- c(1,1,0,0,0,rep(0,3)) # intercept for race = 1, object = 0 (white-gun)
ITmat[4,] <- c(1,1,0,0,1,rep(0,3)) # intercept for race = 1, object = 1 (white-tool)

Iparest <- ITmat %*% parms          # see above for notation
Inewvc <- ITmat %*% vcmat %*% t(ITmat)
Ises <- sqrt(diag(Inewvc)) 

intercepts = cbind(Iparest, Ises) %>% as.data.frame()
names(intercepts) = c("Intercept", "Intercept_SE")

forPlotting = cbind(slopes, intercepts)

# label for understanding
forPlotting$Condition = c("Black_gun", 
                          "Black_tool",
                          "White_gun",
                          "White_tool")


# BINGO -------------------------------------------------------------------
ggplot(trialOrderDat, aes(TrialOrder.c, MeanAmp, alpha = Condition, color = Condition, shape = Condition)) +
  geom_point() +
  geom_abline(data = forPlotting, aes(intercept=Intercept, slope=Slope, color = Condition), size=1)+
  labs(x = "Error number, centered by subject", y = "ERN mean amplitude (uV)") +
  scale_shape_manual(values=c(1,19,1,19)) +
  scale_alpha_manual(values=c(.1,.1,.1,.1)) +
  scale_color_manual(values=c("dodgerblue", "blue", "red", "darkred")) +
  theme_bw() +
  scale_y_continuous(limits =c(-7.5, 10), expand=c(0,0)) +
  scale_x_continuous(expand=c(0,0)) +
  ggtitle("Errors are ordered and subject-centered") +
  theme(plot.title = element_text(hjust = 0.5)) # center title

```

##### Simple slopes

Error order number is rescaled to range from -5 to 5. 
``` {r simple5, echo = FALSE}
trialOrderDat$TrialOrder.c.s = trialOrderDat$TrialOrder.c/14.1

plot5.d = lmer(MeanAmp ~ Race*Object*TrialOrder.c.s + (Race*Object|Subject) + (1|Electrode), dat = trialOrderDat)

parms <- fixef(plot5.d) # fixed parameters from model
vcmat <- vcov(plot5.d) # variance/covariance matrix of fixed effects

## each row of this matrix defines entries of parms that we want to combine:
Tmat <- matrix(NA,4,8)
Tmat[1,] <- c(rep(0,3),1,0,0,0,0) # weights for estimates for race = 0, object = 0 
Tmat[2,] <- c(rep(0,3),1,0,0,1,0) # weights for estimates for race = 0, object = 1
Tmat[3,] <- c(rep(0,3),1,0,1,0,0) # weights for estimates for race = 1, object = 0
Tmat[4,] <- c(rep(0,3),1,0,1,1,1) # weights for estimates for race = 1, object = 1

parest <- Tmat %*% parms          # see above for notation
newvc <- Tmat %*% vcmat %*% t(Tmat)
ses <- sqrt(diag(newvc)) 

## final results
fin = cbind(parest, ses) %>% as.data.frame()
names(fin) = c("est", "ses")

# to calculate 95% CI intervals, lower bound = m - 2*SE, upper bound = m + 2*SE

fin$lbnd = fin$est - 2*fin$ses
fin$ubnd = fin$est + 2*fin$ses

fin = format(fin, digits = 3)

# relabel for understanding
fin$Race = c("Black", "Black", "White", "White")
fin$Object = c("gun", "tool", "gun", "tool")
fin$Color = c("light blue", "dark blue", "light red", "dark red")

fin = rename(fin, Estimate = est, SE = ses, ci95_lower = lbnd, ci95_upper = ubnd)

# display
fin
```  

#### Model output
The intercept, slopes of Race and Object and their interaction are allowed to vary by subject. The intercept is allowed to vary by electrode. *Categorical variables are effect coded.*   
  
For each subject, error trials are numbered (in order), centered, and rescaled to range from -5 to 5.   

``` {r sc, echo = FALSE}
# same model, but with effect coding
subcentered = lmer(MeanAmp ~ Race.e*Object.e*TrialOrder.c.s + (Race.e*Object.e|Subject) + (1|Electrode), dat = trialOrderDat)
```
  
**Random effects:**  
``` {r sc_random, echo = FALSE}
summary(subcentered)$varcor
```

**Fixed effects:**
``` {r sc_fixed, echo = FALSE} 
round(summary(subcentered)$coefficients[c(1:3,5),1:5], digits = 4)
round(summary(subcentered)$coefficients[c(4,6:8),1:5], digits = 3)
```


### 6. Looking at the ERN over the course of the experiment: Ordered errors by trial type
##### - Each error is ordered for each subject, separately for each trial type
  
**Slopes and estimates of lines are from the MLM, not fitted with OLS.  Negative is plotted downward.** 
  
``` {r subtrialtype, echo=F, warning=F}

trialTypeList = c("Black_gun", "Black_tool", "White_gun", "White_tool")

trialTypeDat = NULL
# order errors by trial type for each subject
for (i in unique(dat$Subject)) {
  for (l in trialTypeList) {
    # take error trials, renumber them by order
    err = dat[dat$Subject == i & dat$Condition == l,] %>% 
      filter(!is.na(Trial))
    err$TrialOrder.type = rep(1:length(unique(err$Trial)), each = 9)
    
    trialTypeDat = rbind(trialTypeDat, err)
  }
}

# fit model to plot simple slopes
plot5.d = lmer(MeanAmp ~ Race*Object*TrialOrder.type + (Race*Object|Subject) + (1|Electrode), dat = trialTypeDat)

parms <- fixef(plot5.d) # fixed parameters from model
vcmat <- vcov(plot5.d) # variance/covariance matrix of fixed effects

# First calculate slopes

## each row of this matrix defines entries of parms that we want to combine:
STmat <- matrix(NA,4,8)
STmat[1,] <- c(rep(0,3),1,0,0,0,0) # slope for race = 0, object = 0 (black-gun)
STmat[2,] <- c(rep(0,3),1,0,0,1,0) # slope for race = 0, object = 1 (black-tool)
STmat[3,] <- c(rep(0,3),1,0,1,0,0) # slope for race = 1, object = 0 (white-gun)
STmat[4,] <- c(rep(0,3),1,0,1,1,1) # slope for race = 1, object = 1 (white-tool)

Sparest <- STmat %*% parms          # see above for notation
Snewvc <- STmat %*% vcmat %*% t(STmat)
Sses <- sqrt(diag(Snewvc)) 

slopes = cbind(Sparest, Sses) %>% as.data.frame()
names(slopes) = c("Slope", "Slope_SE")

# Next calculate intercepts

## each row of this matrix defines entries of parms that we want to combine:
ITmat <- matrix(NA,4,8)
ITmat[1,] <- c(1,0,0,0,0,rep(0,3)) # intercept for race = 0, object = 0 (black-gun)
ITmat[2,] <- c(1,0,1,0,0,rep(0,3)) # intercept for race = 0, object = 1 (black-tool)
ITmat[3,] <- c(1,1,0,0,0,rep(0,3)) # intercept for race = 1, object = 0 (white-gun)
ITmat[4,] <- c(1,1,0,0,1,rep(0,3)) # intercept for race = 1, object = 1 (white-tool)

Iparest <- ITmat %*% parms          # see above for notation
Inewvc <- ITmat %*% vcmat %*% t(ITmat)
Ises <- sqrt(diag(Inewvc)) 

intercepts = cbind(Iparest, Ises) %>% as.data.frame()
names(intercepts) = c("Intercept", "Intercept_SE")

forPlotting = cbind(slopes, intercepts)

# label for understanding
forPlotting$Condition = c("Black_gun", 
                          "Black_tool",
                          "White_gun",
                          "White_tool")


# BINGO -------------------------------------------------------------------
ggplot(trialTypeDat, aes(TrialOrder.type, MeanAmp, alpha = Condition, color = Condition, shape = Condition)) +
  geom_point() +
  geom_abline(data = forPlotting, aes(intercept=Intercept, slope=Slope, color = Condition), size=1)+
  labs(x = "Error number, by trial type", y = "ERN mean amplitude (uV)") +
  scale_shape_manual(values=c(1,19,1,19)) +
  scale_alpha_manual(values=c(.1,.1,.1,.1)) +
  scale_color_manual(values=c("dodgerblue", "blue", "red", "darkred")) +
  theme_bw() +
  scale_y_continuous(limits =c(-7.5, 10), expand=c(0,0)) +
  scale_x_continuous(expand=c(0,0)) +
  ggtitle("Errors are ordered by trial type") +
  theme(plot.title = element_text(hjust = 0.5)) # center title

```

##### Simple slopes

Error order number is rescaled to range from 0 to 10. 
``` {r simple6, echo = FALSE}
trialTypeDat$TrialOrder.type.s = trialTypeDat$TrialOrder.type/5.9

plot5.d = lmer(MeanAmp ~ Race*Object*TrialOrder.type.s + (Race*Object|Subject) + (1|Electrode), dat = trialTypeDat)

parms <- fixef(plot5.d) # fixed parameters from model
vcmat <- vcov(plot5.d) # variance/covariance matrix of fixed effects

## each row of this matrix defines entries of parms that we want to combine:
Tmat <- matrix(NA,4,8)
Tmat[1,] <- c(rep(0,3),1,0,0,0,0) # weights for estimates for race = 0, object = 0 
Tmat[2,] <- c(rep(0,3),1,0,0,1,0) # weights for estimates for race = 0, object = 1
Tmat[3,] <- c(rep(0,3),1,0,1,0,0) # weights for estimates for race = 1, object = 0
Tmat[4,] <- c(rep(0,3),1,0,1,1,1) # weights for estimates for race = 1, object = 1

parest <- Tmat %*% parms          # see above for notation
newvc <- Tmat %*% vcmat %*% t(Tmat)
ses <- sqrt(diag(newvc)) 

## final results
fin = cbind(parest, ses) %>% as.data.frame()
names(fin) = c("est", "ses")

# to calculate 95% CI intervals, lower bound = m - 2*SE, upper bound = m + 2*SE

fin$lbnd = fin$est - 2*fin$ses
fin$ubnd = fin$est + 2*fin$ses

fin = format(fin, digits = 3)

# relabel for understanding
fin$Race = c("Black", "Black", "White", "White")
fin$Object = c("gun", "tool", "gun", "tool")
fin$Color = c("light blue", "dark blue", "light red", "dark red")

fin = rename(fin, Estimate = est, SE = ses, ci95_lower = lbnd, ci95_upper = ubnd)

# display
fin
```  

#### Model output
The intercept, slopes of Race and Object and their interaction are allowed to vary by subject. The intercept is allowed to vary by electrode. *Categorical variables are effect coded.*   
  
For each subject, error trials are numbered (in order) separately for each trial type and rescaled to range from 0 to 10.   

``` {r st, echo = FALSE}
# same model, but with effect coding
trialTypeDat$Race.e = NA
trialTypeDat$Race.e[trialTypeDat$Race == "Black"] = -1
trialTypeDat$Race.e[trialTypeDat$Race == "White"] = 1

trialTypeDat$Object.e = NA
trialTypeDat$Object.e[trialTypeDat$Object == "gun"] = -1
trialTypeDat$Object.e[trialTypeDat$Object == "tool"] = 1


subcentered = lmer(MeanAmp ~ Race.e*Object.e*TrialOrder.type.s + (Race.e*Object.e|Subject) + (1|Electrode), dat = trialTypeDat)
```
  
**Random effects:**  
``` {r st_random, echo = FALSE}
summary(subcentered)$varcor
```

**Fixed effects:**
``` {r st_fixed, echo = FALSE} 
round(summary(subcentered)$coefficients[c(1:3,5),1:5], digits = 4)
round(summary(subcentered)$coefficients[c(4,6:8),1:5], digits = 3)
```

